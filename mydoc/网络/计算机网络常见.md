### q1:三次握手 & 四次挥手  能画出状态图

##### 三次握手

![](https://github.com/No8LaVine/MyCode/blob/master/images/net1.png)

* 第一次握手：客户端给服务端发送一个**SYN**报文
* 第二次握手：服务器收到 **SYN** 报文之后，会应答一个 **SYN**+**ACK** 报文。
* 第三次握手：客户端收到 **SYN**+**ACK** 报文之后，会回应一个 **ACK** 报文。
* 服务器收到 ACK 报文之后，三次握手建立完成。

###### 步骤详解

* 最开始，客户端处于**closed**状态，服务端处于**listen**状态，然后

* 第一次握手：客户端给服务端发送一个**SYN**报文，并指明客户端的初始化序列号**ISN**，此时客户端处于**SYN_Send**状态

  客户端什么都不能确认；服务端确认了对方发送正常

* 第二次握手：第二次握手：服务器收到客户端的 **SYN** 报文之后，会以自己的 **SYN** 报文作为应答，并且也是指定了自己的初始化序列号 **ISN(s)**，同时会把客户端的 **ISN** + 1 作为 **ACK** 的值，表示自己已经收到了客户端的 **SYN**，此时服务器处于 **SYN_RCVD** 的状态。

  客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：自己接收正常，对方发送正常

* 第三次握手：客户端收到 **SYN** 报文之后，会发送一个 **ACK** 报文，当然，也是一样把服务器的 **ISN** + 1 作为 **ACK** 的值，表示已经收到了服务端的 **SYN** 报文，此时客户端处于 **establised** 状态。

  客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：自己发送、接收正常，对方发送、接收正常。

  

**Q1: 为什么要三次握手？**

**A1：建立可靠的通信信道，确认双方发送和接收数据都是正常的**



**Q2：第二次握手为什么要回传SYN？SYN是什么？**

**A2：SYN是tcp/ip建立连接时的握手信号。**



**Q3：三次握手的作用**

**A3：**

**1、确认双方的接受能力、发送能力是否正常。**

**2、指定自己的初始化序列号，为后面的可靠传送做准备。**

**3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。**



**Q4：ISN是固定的吗？**

**A4：三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的**

**ISN随时间而变化。ISN可以看作是一个32比特的计数器，每4ms加1，这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。**



**Q5：什么是半连接队列？**

**A5：服务端第一次收到客户端的SYN之后，就会处于SYN_RCVD状态，此时双方还没有建立起连接，服务端会把此种状态下的请求连接放在一个队列里，这种队列称为半连接队列。完成三次挥手的称之为全连接队列。建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。**

~~~markdown
这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s,
~~~



**Q6：三次握手过程中可以携带收据吗？**

**A6：第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。**

**什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。**

**而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据。**



##### 四次挥手

![](https://github.com/No8LaVine/MyCode/blob/master/images/net2.jpg)

刚开始客户端喝服务端都处于establised 状态，然后客户端先发起关闭请求，则：

* 第一次挥手：客户端发送一个**FIN**报文，用来关闭客户端到服务器的数据传送，报文中会指定一个序列号，此时客户端处于**FIN_WAIT1**状态。
* 第二次挥手：服务端收到**FIN**后，会发送**ACK**报文，且把客户端的序列号+1作为 **ACK** 的报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 **CLOSE_WAIT** 状态。
* 第三次挥手：服务器-关闭与客户端的连接，发送 **FIN** 报文给客户端，并指定一个序列号，此时服务端处于**LAST_ACK**的状态。
* 第四次挥手：客户端收到FIN后，发送一个**ACK**报文作为应答，且把服务端得序列号值+1作为自己**ACK**报文的序列号值，此时客户端处于**TIME_WAIT**状态。需要确保服务端收到**ACK**报文之后才会进入**CLOSED**状态。
* 服务端收到**ACK**报文，关闭连接，处于**CLOSED**状态。

**time_wait 状态**

![](https://github.com/No8LaVine/MyCode/blob/master/images/net3.png)

