### 主从复制

--------

~~~
mysql数据库提供了一种主从备份的机制，其实就是把主数据库的所有的数据同时写到备份的数据库中。实现mysql数据库的热备份。
~~~

##### 要求

~~~
主从数据库最好版本一致，要实现热备mysql的版本都高于3.2。还有一个基本的原则就是作为从数据库的数据版本可以高于主服务器数据库的版本，但是不可以低于主服务器的数据库版本。
~~~

##### 配置

**主库配置**

**修改Master上MySQL配置文件my.cnf**

~~~
[mysqld]
log-bin=mysql-bin   // [必须]启用二进制日志
server-id=1         // [必须]服务器唯一ID
binlog-do-db = db1  // #需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可                   
~~~

**检查MySQL是否允许远程连接**

~~~
 bind-address = 0.0.0.0       #这样表示允许所有网段连接
~~~

**重启MySQL，创建允许从服务器同步数据的账户**

~~~
mysql> GRANT REPLICATION backup ON *.* to 'backup'@'192.168.128.%' identified by 'backup';
mysql> FLUSH PRIVILEGES;
~~~

**从库配置**

**修改Slave上MySQL配置文件my.cnf**

~~~
[mysqld]
server_id = 2
log-bin = mysql-bin
log-slave-updates
sync_binlog = 0
#log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作
innodb_flush_log_at_trx_commit = 0        
#指定slave要复制哪个库
replicate-do-db = db         
#MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据
slave-net-timeout = 60                    
log_bin_trust_function_creators = 1
~~~

**执行同步命令**

~~~
#执行同步命令，设置主服务器ip，同步账号密码，同步位置
mysql>change master to master_host='10.10.20.111',master_user='account',master_password='123456',master_log_file='mysql-bin.000033',master_log_pos=337523;
#开启同步功能
mysql>start slave;
~~~

**查看Slave状态**

~~~
mysql>show slave status\G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 10.10.20.111
                  Master_User: account
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000033
          Read_Master_Log_Pos: 337523
               Relay_Log_File: db2-relay-bin.000002
                Relay_Log_Pos: 337686
        Relay_Master_Log_File: mysql-bin.000033
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
          ...
~~~

##### 原理

~~~
Master更新写入二进制日志文件，并维护日志文件的索引。Slave从二进制文件读取更新内容，在Slave上重新执行一遍来进行备份。
~~~

`MySQL` 主从复制默认是 **异步的模式**

###### Master

>1、当主节点上进行 `insert、update、delete` 操作时，会按照时间先后顺序写入到 `binlog` 中；
>
>2、当从节点连接到主节点时，主节点会创建一个叫做 `binlog dump` 的线程；
>
>3、一个主节点有多少个从节点，就会创建多少个 `binlog dump` 线程；
>
>4、当主节点的 `binlog` 发生变化的时候，也就是进行了更改操作，`binlog dump` 线程就会通知从节点 (`Push`模式)，并将相应的 `binlog` 内容发送给从节点；

###### Slave

>当开启主从同步的时候，从节点会创建两个线程用来完成数据同步的工作。
>
>**I/O线程：** 此线程连接到主节点，主节点上的 `binlog dump` 线程会将 `binlog` 的内容发送给此线程。此线程接收到 `binlog` 内容后，再将内容写入到本地的 `relay log`。
>
>**SQL线程：** 该线程读取 `I/O` 线程写入的 `relay log`，并且根据 `relay log` 的内容对从数据库做对应的操作。

![](https://github.com/No8LaVine/MyCode/blob/master/images/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B61.jpg)

主从配置一般都是和读写分离相结合，主服务器负责写数据，从服务器负责读数据，并保证主服务器的数据及时同步到从服务器。

**relay log 是怎么产生的呢？**

从服务器 `I/O` 线程将主服务器的 `Binlog` 日志读取过来，解析到各类 `Events` 之后记录到从服务器本地文件，这个文件就被称为 `relay log`。

##### binlog写入机制

`binlog`的写入逻辑比较简单：事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到`binlog`文件中。

~~~
一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。

系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。

事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。
~~~

![](https://github.com/No8LaVine/MyCode/blob/master/images/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B62.png)

可以看到，每个线程有自己`binlog cache`，但是共用同一份`binlog`文件。

- 图中的`write`，指的就是指把日志写入到文件系统的`page cache`，并没有把数据持久化到磁盘，所以速度比较快。
- 图中的`fsync`，才是将数据持久化到磁盘的操作。一般情况下，我们认为`fsync`才占磁盘的`IOPS`。

`write` 和`fsync`的时机，是由参数`sync_binlog`控制的：

1. `sync_binlog=0`的时候，表示每次提交事务都只`write`，不`fsync`；
2. `sync_binlog=1`的时候，表示每次提交事务都会执行`fsync`；
3. `sync_binlog=N(N>1)`的时候，表示每次提交事务都`write`，但累积`N`个事务后才`fsync`。

因此，在出现`IO`瓶颈的场景里，将`sync_binlog`设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。

但是，将`sync_binlog`设置为N，对应的风险是：如果主机发生异常重启，会丢失最近`N`个事务的`binlog`日志。



#### MySQL-5.5支持半同步复制

~~~
早期的MySQL复制只能是基于异步来实现，从MySQL-5.5开始，支持半自动复制。在以前的异步（asynchronous）复制中，主库在执行完一些事务后，是不会管备库的进度的。如果备库处于落后，而更不幸的是主库此时又出现Crash（例如宕机），这时备库中的数据就是不完整的。简而言之，在主库发生故障的时候，我们无法使用备库来继续提供数据一致的服务了。Semisynchronous Replication(半同步复制)则一定程度上保证提交的事务已经传给了至少一个备库。Semi synchronous中，仅仅保证事务的已经传递到备库上，但是并不确保已经在备库上执行完成了。

此外，还有一种情况会导致主备数据不一致。在某个session中，主库上提交一个事务后，会等待事务传递给至少一个备库，如果在这个等待过程中主库Crash，那么也可能备库和主库不一致，这是很致命的。如果主备网络故障或者备库挂了，主库在事务提交后等待10秒（rpl_semi_sync_master_timeout的默认值）后，就会继续。这时，主库就会变回原来的异步状态。

MySQL在加载并开启Semi-sync插件后，每一个事务需等待备库接收日志后才返回给客户端。如果做的是小事务，两台主机的延迟又较小，则Semi-sync可以实现在性能很小损失的情况下的零数据丢失。
~~~

