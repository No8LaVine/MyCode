### 索引

#### 什么是索引？

​	索引是一种用于快速查询和检索数据的数据结构。索引的本质是一种排好序的数据结构。常见的索引结构有: `BTree`， `B+Tree`和 `Hash`。

##### 1.普通索引

* 创建索引

  ~~~mysql
  create index test_index on test(col_name)
  
  alter table test add index test_index2(col_name)
  
  create table test(
  	id int not null,
  	username varchar(16) not null,
  	index test_index (username)
  )
  ~~~

*  删除索引

  ~~~mysql
  drop index test_index on test
  ~~~

##### 2.唯一索引

​	与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

* 创建唯一索引

  ~~~mysql
  create unique index test_index on test(col_name)
  
  alter table test add unique index test_index2(col_name)
  
  create table test(
  	id int not null,
  	username varchar(16) not null,
  	unique index test_index (username)
  )
  ~~~

* 删除唯一索引
  ~~~mysql
  drop unique index test_index on test
  ~~~

  ​	

##### 3.为什么要使用索引？

	- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
	- 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
	- 帮助服务器避免排序和临时表。
	- 将随机`IO`变为顺序`IO`
	- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

##### 4.索引的缺点

 - 创建索引和维护索引需要耗费许多时间：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 `SQL` 执行效率。
- 占用物理存储空间 ：索引需要使用物理文件存储，也会耗费一定空间。

5. ##### 使用索引的注意事项
	
	适合建立索引

		- 在经常需要搜索的列上，可以加快搜索的速度；
	
		- 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
		
		- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
		
		- 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。
		
		- 在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；
	
	不适合建立索引
		- 表记录太少。
		
		- 经常增删改的表。
		
		- 数据重复且分布平均的表字段，因此应该只为最经常查询和经常排序的数据列建立索引（如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果）。
		
		- 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引

	其他注意事项

		- 避免 where 子句中对字段施加函数，这会造成无法命中索引。
		
		- 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
		
		- 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用
	

### MySQL中的索引

​	`MySQL`索引使用的数据结构主要有`B+Tree`索引 和 `Hash`索引 。

##### Hash 索引

	对于哈希索引来说，底层的数据结构就是哈希表，单条记录查询的效率很高，时间复杂度为1，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree、B+Tree索引。

###### Hash索引的缺点

	Hash索引适合精确查找，但是范围查找不适合，因为存储引擎都会为每一行计算一个hash码，hash码都是比较小的，并且不同键值行的hash码通常是不一样的，hash索引中存储的就是Hash码，hash 码彼此之间是没有规律的，
	且 Hash 操作并不能保证顺序性，所以值相近的两个数据，Hash值相差很远，被分到不同的桶中。这就是为什么hash索引只能进行全职匹配的查询，因为只有这样，hash码才能够匹配到数据。
##### BTree

![](https://github.com/No8LaVine/MyCode/blob/master/images/BTree.png)

- 从`BTree`的结构图中可以看到每个节点中不仅包含数据的 `key` 值，还有 `data` 值。
- 而每页的存储空间是有限的，如果 data 比较大，会导致每个节点的 key 存储的较少，当数据量较大的时候，同样会导致B树很深，从而增加了磁盘 IO 的次数，进而影响查询效率。

###### MyISAM和InnoDB实现BTree索引方式的区别

	MyISAM
	B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
	InnoDB
	其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 PS：整理自《Java工程师修炼之道》


​	
​		