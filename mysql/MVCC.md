### MVCC

##### 什么是MVCC？

~~~
1.即多版本并发控制，MVCC是一种并发控制的方法，主要是为了提高数据库的并发性能。
2.最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。
3.引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。
4.在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。
5.找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)
6.也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。
~~~

##### 什么是当前读？

​	读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁；

​	如下操作都是当前读：

~~~
select lock in share mode (共享锁)

select for update (排他锁)

update (排他锁)

insert (排他锁)

delete (排他锁)

串行化事务隔离级别
~~~

##### 什么是快照读？

​	快照读的实现是基于`多版本`并发控制，即`MVCC`，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。

​	**如下操作是快照读**：

~~~
不加锁的select操作（注：事务级别不是串行化）
~~~

**`MVCC`就是为了实现读-写冲突不加锁，而这个读指的就是`快照读`, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现**

##### 当前读，快照读和MVCC的关系

 ~~~
1.准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念

2.而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个
具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现

3.要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等
去完成的，具体可以看下面的MVCC实现原理
 ~~~

##### 数据库并发场景

~~~
读-读：不存在任何问题，也不需要并发控制

读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读

写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失
~~~

##### MVCC解决了哪些问题？

`MVCC`用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的时间戳。为每个数据修改保存一个版本，版本与事务时间戳相关联。读操作只读该事务开始前的数据库的快照。 所以`MVCC`可以为数据库解决以下问题：

~~~
并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。

解决脏读、幻读、不可重复读等事务隔离问题，但不能解决上面的写-写 更新丢失问题
~~~

##### 高并发性能的组合拳

~~~
MVCC + 悲观锁
	MVCC解决读写冲突，悲观锁解决写写冲突

MVCC + 乐观锁
	MVCC解决读写冲突，乐观锁解决写写冲突
~~~



#### MVCC的实现原理

实现原理主要是版本链，`undo`日志 ，`Read View` 来实现的

##### 版本链

数据库中的每行数据，除了我们肉眼看见的数据，还有几个**隐藏字段**，分别是`db_trx_id`、`db_roll_pointer`、`db_row_id`。

~~~
DB_TRX_ID
	6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID。

DB_ROLL_POINTER（版本链关键）
	7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）

DB_ROW_ID
	6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。

实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了
~~~

![](https://github.com/No8LaVine/MyCode/blob/master/images/mvcc1.png)

如上图，`DB_ROW_ID`是数据库默认为该行记录生成的唯一隐式主键，`DB_TRX_ID`是当前操作该记录的事务ID,而`DB_ROLL_PTR`是一个回滚指针，用于配合`undo`日志，指向上一个旧版本。



每次对数据库记录进行改动，都会记录一条`undo`日志，每条`undo`日志也都有一个`roll_pointer`属性（`INSERT`操作对应的`undo`日志没有该属性，因为该记录并没有更早的版本），可以将这些`undo`日志都连起来，串成一个链表，所以现在的情况就像下图一样：

![https://github.com/No8LaVine/MyCode/blob/master/images/mvcc2.png]()

对该记录每次更新后，都会将旧值放到一条`undo`日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个链表，我们把这个链表称之为**版本链**，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务`id`，这个信息很重要，在根据`ReadView`判断版本可见性的时候会用到。

##### undo 日志

`undo log` 主要用于`记录`数据被修改之前的日志，在表信息修改之前先会把数据拷贝到`undo log`里。

当事务进行回滚时可以通过`undo log` 里的日志进行数据还原。

**undo log 的用途**

~~~
保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。

用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。
~~~

**undo log主要分为两种：**

~~~
- insert undo log
  代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃
- update undo log
  事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，
  对应的日志才会被purge线程统一清除
~~~

**purge**

~~~
从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。

为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个
read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge
线程的read view可见，那么这条记录一定是可以被安全清除的。
~~~

##### Read View(读视图)

事务进行快照读操作的时候生产的读视图(`Read View`)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照。记录并维护系统当前活跃事务的`ID`(当每个事务开启时，都会被分配一个`ID`, 这个`ID`是递增的，所以最新的事务，`ID`值越大)

~~~
Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务
能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。
~~~

**Read View几个属性**

~~~
trx_ids: 当前系统活跃(未提交)事务版本号集合。

low_limit_id: Read View生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1

up_limit_id: 记录trx_ids列表中事务ID最小的ID

creator_trx_id: 创建当前read view的事务版本号
~~~

>1.首先比较`DB_TRX_ID` < `up_limit_id`, 如果小于，则当前事务能看到`DB_TRX_ID` 所在的记录，如果大于等于进入下一个判断
>
>2.接下来判断 `DB_TRX_ID` 大于等于 `low_limit_id` , 如果大于等于则代表`DB_TRX_ID` 所在的记录在`Read View`生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断
>
>3.判断`DB_TRX_ID` 是否在活跃事务之中，`trx_ids.contains(DB_TRX_ID)`，如果在，则代表我`Read View`生成时刻，你这个事务还在活跃，还没有`Commit`，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在`Read View`生成之前就已经`Commit`了，你修改的结果，我当前事务是能看见的

#### MVCC整体流程

例：

| 事务1    | 事务2    | 事务3    | 事务4        |
| -------- | -------- | -------- | ------------ |
| 事务开始 | 事务开始 | 事务开始 | 事务开始     |
| ...      | ...      | ...      | 修改且已提交 |
| 进行中   | 快照读   | 进行中   |              |

如表格中，当前事务2对某行数据进行了快照读，数据库为该行数据生成一个`Read view`，假设当前事务ID为`2`，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以`Read View`记录了系统当前活跃事务1，3的`ID`，维护在一个列表上，假设我们称为`trx_ids`。



1. `Read View`不仅仅会通过一个列表`trx_ids`来维护事务2执行**快照读**那刻系统正活跃的事务ID，还会有两个属性`up_limit_id`（记录`trx_ids`列表中事务`ID`最小的`ID`），`low_limit_id`(记录`trx_ids`列表中事务`ID`最大的`ID`，也有人说**快照读**那刻系统尚未分配的下一个事务`ID`也就是目前已出现过的事务**ID**的最大值+1，我更倾向于后者 [>>>资料传送门 | 呵呵一笑百媚生的回答](https://www.zhihu.com/question/66320138/answer/241418502)) ；所以在这里例子中`up_limit_id`就是1，`low_limit_id`就是4 + 1 = 5，`trx_ids`集合的值是1,3，`Read View`如下图

![](https://github.com/No8LaVine/MyCode/blob/master/images/view1.png)

2. 我们的例子中，只有事务4修改过该行记录，并在事务2执行**快照读**前，就提交了事务，所以当前该行当前数据的`undo log`如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的`DB_TRX_ID`去跟`up_limit_id`,`low_limit_id`和`活跃事务ID列表(trx_ids)`进行比较，判断当前事务2能看到该记录的版本是哪个。

![](https://github.com/No8LaVine/MyCode/blob/master/images/view2.png)

3. 所以先拿该记录`DB_TRX_ID`字段记录的事务ID `4`去跟`Read View`的的`up_limit_id`比较，看`4`是否小于`up_limit_id`(1)，所以不符合条件，继续判断 `4` 是否大于等于 `low_limit_id`(5)，也不符合条件，最后判断`4`是否处于`trx_list`中的活跃事务, 最后发现事务ID为`4`的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2**快照读**时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。

![](https://github.com/No8LaVine/MyCode/blob/master/images/view3.png)

4. 也正是`Read View`生成时机的不同，从而造成`RC,RR`级别下**快照读**的结果的不同



#### MVCC相关问题

上面所讲的`Read View`用于支持`RC`（`Read Committed`，读提交）和`RR`（`Repeatable Read`，可重复读）隔离级别的实现。

##### RR、RC生成时机

* `RC`隔离级别下，是每个**快照读**都会生成并获取最新的`Read View`；
* 而在`RR`隔离级别下，则是**同一个事务中**的**第一个快照读**才会创建`Read View`, 之后的**快照读**获取的都是同一个`Read View`，之后的查询就不会重复生成了，所以**一个事务的查询结果每次都是一样的**。

##### 解决幻读问题

- **快照读**：通过`MVCC`来进行控制的，不用加锁。按照`MVCC`中规定的“语法”进行增删改查等操作，以避免幻读。
- **当前读**：通过`next-key`锁（行锁+`gap`锁）来解决问题的。（将**两行记录间的空隙加上锁**，阻止新记录的插入；这个锁称为**间隙锁**。）

##### RC、RR级别下的InnoDB快照读区别

- 在`RR`级别下的某个事务的对某条记录的第一次快照读会创建一个快照及`Read View`， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个`Read View`，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个`Read View`，所以对之后的修改不可见；
- 即`RR`级别下，快照读生成`Read View`时，`Read View`会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于`Read View`创建的事务所做的修改均是可见
- 而在`RC`级别下的，事务中，每次**快照读**都会新生成一个快照和`Read View`, 这就是我们在`RC`级别下的事务中可以看到别的事务提交的更新的原因
- 总之在`RC`隔离级别下，是每个**快照读**都会生成并获取最新的`Read View`；而在`RR`隔离级别下，则是同一个事务中的第一个**快照读**才会创建`Read View`, 之后的**快照读**获取的都是同一个`Read View`。

##### RR是如何在RC级的基础上解决不可重复读的？

当前读和快照读在`RR`级别下的区别：

表1：

| 事务A                       | 事务B                                      |
| --------------------------- | ------------------------------------------ |
| 开启事务                    | 开启事务                                   |
| 快照读(无影响)查询金额为500 | 快照读查询金额为500                        |
| 更新金额为400               |                                            |
| 提交事务                    |                                            |
|                             | select `快照读`金额为500                   |
|                             | select lock in share mode`当前读`金额为400 |

在**表1**的顺序下，事务`B`的在事务`A`提交修改后的**快照读**是旧版本数据，而**当前读**是实时新数据400

表2：

| 事务A                         | 事务B                                      |
| ----------------------------- | ------------------------------------------ |
| 开启事务                      | 开启事务                                   |
| 快照读（无影响）查询金额为500 |                                            |
| 更新金额为400                 |                                            |
| 提交事务                      |                                            |
|                               | select `快照读`金额为400                   |
|                               | select lock in share mode`当前读`金额为400 |

而在**表2**这里的顺序中，事务`B`在事务`A`提交后的**快照读**和**当前读**都是实时的新数据400，这是为什么呢？

- **表1**与**表2**唯一区别仅仅是**表1**的事务`B`在事务`A`修改金额前**快照读**过一次金额数据，而表2的事务`B`在事务`A`修改金额前没有进行过**快照读**。
- 我们这里测试的是**更新**，同时**删除**和更新也是一样的，如果事务`B`的**快照读**是在事务`A`操作之后进行的，事务`B`的**快照读**也是能读取到最新的数据的



#### 总结

从以上的描述中我们可以看出来，所谓的`MVCC`指的就是在使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的**版本链**的过程，这样子可以使不同事务的**读-写**、**写-读**操作**并发执行**，从而提升系统性能。

##### 一般我们认为`MVCC`有下面几个特点：

- 每行数据都存在一个版本，每次数据更新时都更新该版本
- 修改时`Copy`出当前版本, 然后随意修改，各个事务之间无干扰
- 保存时比较版本号，如果成功(`commit`)，则覆盖原记录, 失败则放弃`copy(rollback)`
- 就是每行都有版本号，保存时根据版本号决定是否成功，**听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功**

##### 而InnoDB实现MVCC的方式是:

- 事务以排他锁的形式修改原始数据
- 把修改前的数据存放于`undo log`，通过回滚指针与主数据关联
- 修改成功（`commit`）啥都不做，失败则恢复`undo log`中的数据（`rollback`）

##### 二者最本质的区别是: 

当修改数据时是否要**排他锁**，如果锁定了还算不算是`MVCC`？

- `Innodb`的实现真算不上`MVCC`, 因为并没有实现核心的多版本共存, `undo log` 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的`MVCC`是难以实现的, 当事务仅修改一行记录使用理想的`MVCC`模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的`MVCC`就无能为力了。
- 比如, 如果事务`A`执行理想的`MVCC`, 修改`Row1`成功, 而修改`Row2`失败, 此时需要回滚`Row1`, 但因为`Row1`没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚`Row1`的内容，则会破坏事务`B`的修改结果，导致事务`B`违反`ACID`。 这也正是所谓的 **第一类更新丢失**的情况。
- 也正是因为`InnoDB`使用的`MVCC`中结合了**排他锁**, 不是纯的`MVCC`, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。



参考：

https://segmentfault.com/a/1190000012650596

https://juejin.cn/post/6871046354018238472

https://www.cnblogs.com/xuwc/p/13873611.html