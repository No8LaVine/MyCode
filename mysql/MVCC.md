### MVCC

##### 什么是MVCC？

~~~
1.即多版本并发控制，MVCC是一种并发控制的方法，主要是为了提高数据库的并发性能。
2.最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。
3.引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。
4.在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。
5.找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)
6.也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。
~~~

##### 什么是当前读？

​	读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁；

​	如下操作都是当前读：

~~~
select lock in share mode (共享锁)

select for update (排他锁)

update (排他锁)

insert (排他锁)

delete (排他锁)

串行化事务隔离级别
~~~

##### 什么是快照读？

​	快照读的实现是基于`多版本`并发控制，即`MVCC`，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。

​	如下操作是快照读：

~~~
不加锁的select操作（注：事务级别不是串行化）
~~~

**`MVCC`就是为了实现读-写冲突不加锁，而这个读指的就是`快照读`, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现**

##### 当前读，快照读和MVCC的关系

 ~~~
1.准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念

2.而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现

3.要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理
 ~~~

##### 数据库并发场景

~~~
读-读：不存在任何问题，也不需要并发控制

读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读

写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失
~~~

##### MVCC解决了哪些问题？

`MVCC`用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的时间戳。为每个数据修改保存一个版本，版本与事务时间戳相关联。读操作只读该事务开始前的数据库的快照。 所以`MVCC`可以为数据库解决以下问题：

~~~
并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。

解决脏读、幻读、不可重复读等事务隔离问题，但不能解决上面的写-写 更新丢失问题
~~~

##### 高并发性能的组合拳

~~~
MVCC + 悲观锁
	MVCC解决读写冲突，悲观锁解决写写冲突

MVCC + 乐观锁
	MVCC解决读写冲突，乐观锁解决写写冲突
~~~



#### MVCC的实现原理

实现原理主要是版本链，`undo`日志 ，`Read View` 来实现的

##### 版本链

数据库中的每行数据，除了我们肉眼看见的数据，还有几个**隐藏字段**，分别是`db_trx_id`、`db_roll_pointer`、`db_row_id`。

~~~
DB_TRX_ID
	6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID。

DB_ROLL_POINTER（版本链关键）
	7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）

DB_ROW_ID
	6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。

实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了
~~~

![](https://github.com/No8LaVine/MyCode/blob/master/images/mvcc1.png)

如上图，`DB_ROW_ID`是数据库默认为该行记录生成的唯一隐式主键，`DB_TRX_ID`是当前操作该记录的事务ID,而`DB_ROLL_PTR`是一个回滚指针，用于配合`undo`日志，指向上一个旧版本。



每次对数据库记录进行改动，都会记录一条`undo`日志，每条`undo`日志也都有一个`roll_pointer`属性（`INSERT`操作对应的`undo`日志没有该属性，因为该记录并没有更早的版本），可以将这些`undo`日志都连起来，串成一个链表，所以现在的情况就像下图一样：

![https://github.com/No8LaVine/MyCode/blob/master/images/mvcc2.png]()

对该记录每次更新后，都会将旧值放到一条`undo`日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个链表，我们把这个链表称之为**版本链**，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务`id`，这个信息很重要，在根据`ReadView`判断版本可见性的时候会用到。

##### undo 日志

`undo log` 主要用于`记录`数据被修改之前的日志，在表信息修改之前先会把数据拷贝到`undo log`里。

当事务进行回滚时可以通过`undo log` 里的日志进行数据还原。

**undo log 的用途**

~~~
保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。

用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。
~~~

**undo log主要分为两种：**

~~~
- insert undo log
  代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃
- update undo log
  事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除
~~~

**purge**

~~~
从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。

为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。
~~~

##### Read View(读视图)

事务进行`快照读`操作的时候生产的`读视图`(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个`快照`。



参考：

https://segmentfault.com/a/1190000012650596

https://juejin.cn/post/6871046354018238472

https://www.cnblogs.com/xuwc/p/13873611.html