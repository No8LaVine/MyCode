### 事务和锁

----

#### 事务

##### 事务的四大特性

~~~
1.原子性：事务必须是原子单元，不可再分割。事务的操作要么全部执行，要么全部不执行。

2.一致性：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。举例，A\B两人共有10块，那么他们不管进行什么操作，他们的钱加起来必须是100。

3.隔离性：一个事务与跟它并发的事务所做的修改隔离。个事务所做的修改在最终提交以前，对其他事务是不可见的（不同隔离级别可能不一样）

4.持久性：事务对数据库的操作是永久性的。一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失
~~~

##### 并发事务带来的问题

~~~
1.第一类丢失更新：count = 100，两个事务同时对它更新，一开始都读取到100，此时A事务更新到101，B事务由于某种原因失败回滚，将count回滚到100，A的更新丢失了。

2.第二类丢失更新：count = 100，两个事务同时对它更新，一开始都读取到100，此时A事务更新到101，B事务也是从100更新到101。由于B事务还是从100增加，A事务的更新丢失了。

3.脏读：A事务读取到了B事务更新但未提交的数据。count = 100。A事务将其更新为101，此时B事务读取count = 101，但A事务失败回滚，count = 100，B事务出现脏读。

4.不可重复读：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读” 

5.幻读：类似不可重复读。但是幻读针对数据的条数。
~~~

##### 幻读和不可重复读的区别

- 不可重复读的重点是**修改**：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）
- 幻读的重点在于**新增或者删除**：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）

##### 数据库隔离级别

~~~
 1.读未提交（READ-UNCOMMITTED）:安全性低，基本不用。可能会导致脏读、幻读或不可重复读。

 2.读已提交（READ-COMMITTED）：Oracle、Sqlserver，允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生

 3.可重复读（REPEATABLE-READ）:MySQL， 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

 4.串行化（SERIALIZABLE）：效率太低基本不用。最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
~~~

| 隔离级别         | **更新丢失** | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ------------ | ---- | ---------- | ---- |
| READ-UNCOMMITTED | ×            | √    | √          | √    |
| READ-COMMITTED   | ×            | ×    | √          | √    |
| REPEATABLE-READ  | ×            | ×    | ×          | √    |
| SERIALIZABLE     | ×            | ×    | ×          | ×    |

##### 实现原理（InnoDB）

~~~
innoDB是mysql默认的存储引擎，默认的隔离级别是RR（Repeatable Read），并且在RR的隔离级别下更进一步，通过多版本并发控制MVCC解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。因此innoDB的RR隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。
~~~

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E4%BA%8B%E5%8A%A11.png)

> 1. 由上图看，事务的实现通过 `redo_log` 和 `undo_log`， 以及锁实现，锁实现事务的隔离
> 2. redo_log 实现持久化和原子性
> 3. undo_log实现一致性

**两种日志均可以视为一种恢复操作**

> redo_log是恢复提交事务修改的页操作
>
> 而undo_log是回滚行记录到特定版本。

**二者记录的内容也不同**

>  redo_log是物理日志，记录页的物理修改操作
>
> undo_log是逻辑日志，根据每行记录进行记录。



##### redo log

由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。

**例子**

`redo log`的更新流程如下，以一次`Update` 操作为例。

* 执行update操作。
* 先将原始数据从磁盘读取到内存，修改内存中的数据。
* 生成一条重做日志写入`redo log buffer`，记录数据被修改后的值。
* 当事务提交时，需要将`redo log buffer`中的内容刷新到`redo log file`。
* 事务提交后，也会将内存中修改数据的值写入磁盘。

**恢复机制**

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E4%BA%8B%E5%8A%A12.png)

~~~
LSN(Log Sequence Number) 日志序列号，Innodb里，LSN占8个字节，且是单调递增的，代表的含义有: 重做日志写入的总量、checkpoint的位置、页的版本。

假设在LSN=10000的时候数据库出现故障，磁盘中checkpoint为10000，表示磁盘已经刷新到10000这个序列号，当前redolog的checkpoint是13000，则需要恢复10000-13000的数据。
~~~

**redo log为什么可以实现事务的原子性和持久性。**

- 原子性，是`redo log`记录了事务期间操作的物理日志，事务提交之前，并没有写入磁盘，保存在内存里，如果事务失败，数据库磁盘不会有影响，回滚掉事务内存部分即可。
- 持久性，`redo log` 会在事务提交时将日志存储到磁盘`redo log  file`，保证日志的持久性。

#### 锁（InnoDB）

~~~
行锁：锁表中对应的行，只限制当前行的读写，计算机资源开销大，加锁校慢，同时会出现死锁，但锁定粒度小，锁冲突的概率最低，并发度最高，性能高。

表锁：锁整张表，限制的是整张表的数据读写，计算机资源开销小，对比行锁，加锁快，也不会出现死锁，但锁定粒度大，锁冲突的概率最高，并发度最低，性能低。

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

行锁和表锁，在不同引擎还有所区别，MyISAM只有表锁，没有行锁，不支持事务。 InnoDB 有行锁和表锁，支持事务
~~~

**限制条件：**

- 行锁的实现，`SQL`语句必须使用索引。如果没有使用索引，则变成了表锁。

##### 乐观锁

~~~
每次操作数据的时候不认为数据会发生修改，但在更新时会判断在此期间数据是否发生修改。如果修改了，返回给用户错误信息，让用户决定如何做。
~~~

**实现方式：**

~~~
1）版本号（version）:为数据增加一个version字段，每次更新给这个字段+1。读取数据的同时把version读出来，更新的时候比较数据库表当前version与我们第一次
  取出来的是否一致，如果一致则更新，如果不一致返回无法更新的通知给用户
  
2）时间戳（timestamp）：和版本号基本一样，只是使用时间戳判断。注意时间戳使用数据库时间而不是业务系统时间。
 
3）待更新字段：和版本号相似，区别是不增加额外字段。假如数据库有个字段count，更新的时候拿数据库中count的值与我们之前读到的比较，一致则更新，不一致失效。

4）所有字段：和版本号相似，区别是用所有字段做版本控制。
~~~

##### 悲观锁

```
认为数据会随时修改，所以整个数据处理过程都会将数据加锁。悲观锁一般都是依靠关系数据库的锁机制，关系数据库中的行锁，表锁，读写锁都是悲观锁。
```

**实现方式：**

**共享锁（S锁）：**

~~~
也称读锁
S 锁和 S 锁是 兼容 的，事务A对对象T加S锁，其他事务也只能对T加S锁。多个事务可以同时读，但是不能有写操作。直到事务A释放S锁。

加锁方式：select * from table where ... lock in share mode

记住，行锁查询是需要具备索引条件。比如执行: select * from user where id=1 lock in share mode. 其中 id 是主键。
~~~

**排它锁（X锁）：**

~~~
也称写锁

X 锁和其它锁都不兼容，事务A对对象T加X锁，其他事务不能对T加任何锁，只有事务A可以读写对象T，直到A释放X锁。

加锁方式：select * from table where ... for update 比如执行： select name from user where id=1 for update.其中 id 是主键
~~~

**更新锁（U锁）：**

~~~
用来预定对此页加X锁，允许其他事务读，但不允许再加X锁或U锁，当被读取的页将要更新时，则升级为X锁，U锁直到事务结束才释放。
~~~

**如何释放锁**

~~~
非事务中，语句执行完毕，立即释放锁

行锁在事务中，只有等当前事务进行了commit or rollback操作才能释放锁。
~~~

##### 意向锁

**意向共享锁(IS)**

~~~
事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前，必须先取得该表的 IS 锁。
~~~

**意向排他锁(IX)**

~~~
事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前，必须先取得该表的 IX 锁。
~~~

**注**：意向共享锁和意向排他锁是数据库主动加的，不需要我们手动处理。对于 `UPDATE、DELETE` 和 `INSERT` 语句，`InnoDB` 会自动给数据集加排他锁。

意向锁的主要目的是为了使得 **行锁** 和 **表锁** 共存。表1 列出了行级锁和表级意向锁的兼容性。

| **锁类型** | **X** | **IX** | **S** | **IS** |
| :--------- | :---- | :----- | :---- | :----- |
| **X**      | 冲突  | 冲突   | 冲突  | 冲突   |
| **IX**     | 冲突  | 兼容   | 冲突  | 兼容   |
| **S**      | 冲突  | 冲突   | 兼容  | 兼容   |
| **IS**     | 冲突  | 兼容   | 兼容  | 兼容   |

##### 行锁

**间隙锁**（`Gap Lock`）

* **间隙锁是封锁索引记录中的间隔**，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。

* 行锁和间隙锁共同组成的（`next-key lock`），来实现防止幻读

**产生间隙锁的条件（RR事务隔离级别下；）：**

> 1. 使用普通索引锁定；
> 2. 使用多列唯一索引；
> 3. 使用唯一索引锁定多行记录。

~~~
当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。 举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,...,100,101，下面的SQL：
Select * from  emp where empid > 100 for update;

是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。
~~~

**目的**

`InnoDB`使用间隙锁的目的

* 一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了`empid`大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；

* 另外一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下`InnoDB`使用间隙锁的情况，在后续的章节中会做进一步介绍。

##### 表锁

* 如何加表锁？ `innodb` 的行锁是在有索引的情况下，没有索引的表是锁定全表的。**只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！**

* 行级锁都是基于索引的，如果一条`SQL`语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。

##### 锁的算法

`InnoDB` 存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求。

- **Record Locks**

  ~~~
  该锁为索引记录上的锁，如果表中没有定义索引，InnoDB 会默认为该表创建一个隐藏的聚簇索引，并使用该索引锁定记录。
  ~~~

- **Gap Locks**

  ~~~
  该锁会锁定一个范围，但是不括记录本身。可以通过修改隔离级别为 `READ COMMITTED` 或者配置 `innodb_locks_unsafe_for_binlog` 参数为 `ON` 。
  ~~~

- **Next-key Locks**

  ~~~
  该锁就是 Record Locks 和 Gap Locks 的组合，即锁定一个范围并且锁定该记录本身。InnoDB 使用 Next-key Locks 解决幻读问题。需要注意的是，如果索引有唯一属性，则 InnnoDB 会自动将 Next-key Locks 降级为 Record Locks。举个例子，如果一个索引有 1, 3, 5 三个值，则该索引锁定的区间为 `(-∞,1], (1,3], (3,5], (5,+ ∞)` 。
  ~~~

##### 死锁

**死锁** 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

**检测死锁：**

`InnoDB` 存储引擎能检测到死锁的循环依赖并立即返回一个错误。

**解决**

一般做法

~~~
一般比较简单的解决死锁的问题是超时，当两个事务互相等待时，当一个等待时间超过设置的阀值时，则该事务进行回滚，另一个等待的事务则继续进行。可以通过innodb_lock_wait_timeout来设置超时的时间。
~~~

`InnoDB` 

~~~
wait-for graph 等待图的方法来自动检测死锁，如果发现死锁会自动回滚一个事务。将持有最少行级排他锁的事务回滚。在应用程序设计时必须考虑处理死锁，多数情况下重新执行因死锁回滚的事务即可。
~~~

`wait-for graph`**需要2个信息**：

- 锁的信息链表
- 事务等待链表 通过上面链表可以构造一张图，如果图上存在回路，则代表存在死锁。

**死锁实际举例:**

| A                                                | B                                                            |
| ------------------------------------------------ | ------------------------------------------------------------ |
| select * from user where id=2 for update;        | begin                                                        |
|                                                  | select * from user where id=8 for update;                    |
| select * from user where id=8 for update; (等待) |                                                              |
|                                                  | select * from user where id=2 for update; \ ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction |

~~~
如上表，SessionA 先给id=2行加上X锁，SessionB则给id=8加上X锁，SessionA也准备想给id=8加上X锁，从而处于等待中，需要等待SessionB是否id=8的锁，SessionB在未是否id=8的锁之前，又想给id=2加上X锁，从而使SessionA和SessionB互相等待，出现死锁。
~~~

**避免死锁：**

- 在事务开始时，如果有记录要修改，先使用 `SELECT... FOR UPDATE` 语句获取锁，即使这些修改语句是在后面执行。
- 在事务中，如果要更新记录，直接申请**排他锁**。而不是查询时申请**共享锁**、更新时再申请**排他锁**。
  - 这样做会导致，当申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。
  - 简单来说，如果你要更新记录要做两步操作，第一步查询，第二步更新。就不要第一步上共享锁，第二部上排他锁了，直接在第一步就上排他锁，抢占先机。
- 如果事务需要锁定多个表，那么尽量按照相同的顺序使用加锁语句，可以降低产生死锁的机会。
- 通过 `SELECT ... LOCK INSHARE MODE`(共享锁)获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。所以，如果要对行记录进行修改，直接上排他锁。
- 改变事务隔离级别(事务隔离级别在后面详细说明)。

##### 锁的优化建议

锁如果利用不好，会给业务造成大量的卡顿现象，在了解了锁相关的一些知识点后，我们可以有意识的去避免锁带来的一些问题。

1. 合理设计索引，让 `InnoDB` 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 `Query` 的执行。
2. 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。
3. 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。
4. 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 `MySQL` 因为实现事务隔离级别所带来的附加成本。







参考：

https://juejin.cn/post/6844903827611582471

https://juejin.cn/post/6844903797890924552

https://developer.ibm.com/zh/articles/os-mysql-transaction-isolation-levels-and-locks/

https://database.51cto.com/art/201910/604421.htm

https://juejin.cn/post/6844903668571963406

不错：

https://zhuanlan.zhihu.com/p/52312376