### 滑动窗口机制

~~~
为了更有效地进行通信，TCP 协议在数据进行数据传输时，使用滑动窗口机制来同时发送多个数据包。当数据包丢失时，TCP 协议利用数据重发功能重新发送
数据包。因接收端接收数据包的能力不同，TCP 流控制会根据接收端的能力发送适当数量的数据包。
~~~

##### 怎么来的

###### 问题一：如何保证次序

**在我们滑动窗口协议之前，我们如何来保证发送方与接收方之间，每个包都能被收到。并且是按次序的呢？**

~~~
在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包，如图所示
~~~

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A31.png)

* 发送方发送包1，接收方确认包1，必须等接收方确认上个包后才可以发送下一个，发送方发送包2，接收方确认包2，直到数据完全发送完毕，解决了丢包、出错、乱序，但带来一个问题，**吞吐量很低**

###### 问题二：如何提高吞吐量

**那么我们就不能先连发几个包等他一起确认吗？这样的话，我们的速度会不会更快，吞吐量更高些呢？**

~~~
从上图中可以看到，发送端每发送一个数据包，都需要得到接收端的确认应答以后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。
为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。例如，窗口大小为 2，
数据包的传输如图所示。
~~~

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A32.png)

如图，这个就是我们把两个包一起发送，然后一起确认。可以看出我们改进的方案比之前的好很多，所花的时间只是一个来回的时间。接下来，我们还有一个问题：改善了吞吐量的问题

###### 问题三：如何实现最优解？

**问题：我们每次需要发多少个包过去呢？窗口多大才是最优解呢？**

我们能不能把第一个和第二个包发过去后，收到第一个确认包就把第三个包发过去呢？而不是去等到第二个包的确认包才去发第三个包。这样就很自然的产生了我们"**滑动窗口**"的实现。

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A33.jpg)

~~~
在图中，我们可看出灰色1号2号3号包已经发送完毕，并且已经收到Ack。这些包就已经是过去式。4、5、6、7号包是黄色的，表示已经发送了。但是并没有
收到对方的Ack，所以也不知道接收方有没有收到。8、9、10号包是绿色的。是我们还没有发送的。这些绿色也就是我们接下来马上要发送的包。可以看出
我们的窗口正好是11格。后面的11-16还没有被读进内存。要等4号-10号包有接下来的动作后，我们的包才会继续往下发送。

~~~

###### 正常情况

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A34.jpg)

~~~
可以看到4号包对方已经被接收到，所以被涂成了灰色。“窗口”就往右移一格，这里只要保证“窗口”是7格的。 我们就把11号包读进了我们的缓存。进入了
“待发送”的状态。8、9号包已经变成了黄色，表示已经发送出去了。接下来的操作就是一样的了，确认包后，窗口往后移继续将未发送的包读进缓存，把
“待发送“状态的包变为”已发送“。
~~~

###### 丢包情况

有可能我们包发过去，对方的`Ack`丢了。也有可能我们的包并没有发送过去。从发送方角度看就是我们没有收到`Ack`。

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A35.png)

~~~
发生的情况：一直在等Ack。如果一直等不到的话，我们也会把读进缓存的待发送的包也一起发过去。但是，这个时候我们的窗口已经发满了。所以并不能把
12号包读进来，而是始终在等待5号包的Ack。
~~~

**如果我们这个Ack始终不来怎么办呢？**

###### 超时重传

这时候我们有个解决方法：**超时重传** 这里有一点要说明：这个`Ack`是要按顺序的。必须要等到5的`Ack`收到，才会把6-11的`Ack`发送过去。这样就保证了滑动窗口的一个顺序。

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A36.png)

~~~
这时候可以看出5号包已经接受到Ack，后面的6、7、8号包也已经发送过去已Ack。窗口便继续向后移动。
~~~

##### 解决了什么问题？

* 解决网络传输不可靠问题，例如丢包、重复包、出错乱序。
* TCP流量控制，如果发送方数据发送过快，接收方可能会来不及接受，就会造成数据的丢失，滑动窗口机制可以让发送方的发送速率不要太快，要让接收方来得及接收。



参考：

https://zhuanlan.zhihu.com/p/37379780

https://www.cnblogs.com/kubidemanong/p/9987810.html

https://andrewpqc.github.io/2018/07/21/tcp-flow-control-and-congestion-control/

https://juejin.cn/post/6844903588922130440

https://blog.csdn.net/weixin_44478378/article/details/108562138