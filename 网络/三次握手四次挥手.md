### q1:三次握手 & 四次挥手  能画出状态图

##### 三次握手

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.jpg)

> 第一次握手：客户端给服务端发送一个**SYN**报文
>
> 第二次握手：服务器收到 **SYN** 报文之后，会应答一个 **SYN**+**ACK** 报文。
>
> 第三次握手：客户端收到 **SYN**+**ACK** 报文之后，会回应一个 **ACK** 报文。
>
> 服务器收到 ACK 报文之后，三次握手建立完成。

###### 步骤详解

~~~
1.最开始，客户端处于closed状态，服务端处于listen状态，然后

2.第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始化序列号ISN，此时客户端处于SYN_Send状态
  
  客户端什么都不能确认；服务端确认了对方发送正常

3.第二次握手：第二次握手：服务器收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化序列号ISN(s)，同时会把客户端
的ISN + 1 作为   ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_RCVD的状态。

  客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：自己接收正常，对方发送正常

4.第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把服务器的ISN + 1 作为ACK的值，表示已经收到了服务端的SYN报文，此时
客户端处于 establised状态。
  
  客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：自己发送、接收正常，对方发送、接收正常。
~~~

###### 为什么要三次握手？

建立可靠的通信信道，确认双方发送和接收数据都是正常的



###### 第二次握手为什么要回传SYN？SYN是什么?

`SYN`是`tcp/ip`建立连接时的握手信号。

###### 三次握手的作用

> 1. 确认双方的接受能力、发送能力是否正常。
> 2. 指定自己的初始化序列号，为后面的可靠传送做准备。
> 3. 如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。



###### ISN是固定的吗？

~~~
三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。
如果ISN是固定的，攻击者很容易猜出后续的确认号，因此ISN是动态生成的

ISN随时间而变化。ISN可以看作是一个32比特的计数器，每4ms加1，这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，
而导致某个连接的一方对它做错误的解释。
~~~



###### 什么是半连接队列？

服务端第一次收到客户端的`SYN`之后，就会处于`SYN_RCVD`状态，此时双方还没有建立起连接，服务端会把此种状态下的请求连接放在一个队列里，这种队列称为半连接队列。完成三次挥手的称之为全连接队列。建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

~~~markdown
这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户
确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，
一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s,
~~~



###### 三次握手过程中可以携带收据吗？

第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。

~~~
大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者
根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，
第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。

而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是
正常的了，所以能携带数据。
~~~

###### 第一次握手丢包会怎样？

~~~
如果客户端第一个 SYN 包丢了，也就是服务端根本就不知道客户端曾经发过包，那么处理流程主要在客户端。

会触发超时重传机制，重新发包
~~~

###### 第二次握手丢包会怎样？

~~~
服务端收到SYN,并回复客户端SYN + ACK

客户端：
认为第一次握手自己发的SYN包丢了，进入超时重传

服务端：
未收到客户端的回应，也会进行超时重传

同时由于客户端在没有收到「SYN,ACK」时，也会进行重传，当服务端收到客户端重传的SYN后，会立即重新发送「SYN,ACK」包
~~~



###### TCP三次握手的第三次的 ack包丢失会怎样？

**客户端**

~~~
客户端在接收到 SYN+ACK包，它的TCP连接状态就为 established （已连接），表示该连接已经建立

那么如果 第三次握手中的ACK包丢失的情况下，客户端 向 服务端发送数据，服务端将以 RST（该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接）
包响应，表示服务端错误，并进入 CLOSE 状态。
~~~

**服务端**

~~~
第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，
以便客户端重新发送ACK包。

    而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.

    如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。

~~~



##### 四次挥手

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B1.jpg)

刚开始客户端喝服务端都处于**establised** 状态，然后客户端先发起关闭请求，则：

~~~
第一次挥手：客户端发送一个FIN报文，用来关闭客户端到服务器的数据传送，报文中会指定一个序列号，此时客户端处于FIN_WAIT_1状态。

第二次挥手：服务端收到FIN后，会发送ACK报文，且把客户端的序列号+1作为ACK的报文的序列号值，表明已经收到客户端的报文了，此时服务端处于
CLOSE_WAIT状态。客户端收到服务端的ACK应答报文后，之后进入FIN_WAIT_2状态。

第三次挥手：服务器-关闭与客户端的连接，发送FIN报文给客户端，并指定一个序列号，此时服务端处于LAST_ACK的状态。

第四次挥手：客户端收到FIN后，发送一个ACK报文作为应答，且把服务端得序列号值+1作为自己ACK报文的序列号值，此时客户端处于TIME_WAIT状态。
需要确保服务端收到ACK报文之后才会进入CLOSED状态。

服务端收到ACK报文，关闭连接，处于CLOSED状态。
~~~

###### time_wait 状态

![](https://github.com/No8LaVine/MyCode/blob/master/images/net3.png)

###### 为什么要有TIME_WAIT这个状态？

~~~
   假设最终的ACK丢失，主机2将重发FIN，主机1必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果主机2认为发生错误。
   TCP实现必须可靠地终止连接的两个方向(全双工关闭)，主机1必须进入 TIME_WAIT 状态，因为主机1可能面 临重发最终ACK的情形。
~~~



###### 挥手为什么需要四次？

~~~
因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，
当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务
端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
~~~

###### 2MSL等待状态

~~~
TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络
内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP
再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能
在2MSL结束后才能再被使用。
~~~

###### 四次挥手释放连接时，等待2MSL的意义?

~~~
MSL是报文段最大生存时间，超过这个时间报文将被丢弃。

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。
服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，
而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
~~~

**两个理由**

- 保证客户端发送的最后一个`ACK`报文段能够到达服务端。

~~~
这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到
这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段
时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。
~~~

- 防止“已失效的连接请求报文段”出现在本连接中。

~~~
客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的
连接请求报文段。
~~~

###### 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

~~~
理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失
的ACK报文。
~~~







参考：

https://www.cnblogs.com/xiaolincoding/p/12638546.html

https://draveness.me/whys-the-design-tcp-time-wait/